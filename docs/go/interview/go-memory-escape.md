# Go 的内存逃逸分析

### 概念

> Go 在编译阶段确定内存是分配在栈还是在堆上的一种行为

### 底层知识点

1.  栈内存分配和释放非常快
2.  堆内存需要依靠 Go 垃圾回收(如果频繁发生就会比较占 CPU)
3.  通过逃逸分析，可以尽量把那些不需要分配到堆上的变量直接分配到栈上

> Go 的主要目的并不希望程序员关注分配，而是通过编译时的代码分析自动决定。

### 案例分析

```go
func test26() {
	a := []int{1, 2, 3}
	a[1] = 4
}

func main() {
	test26()
}
```

可以使用命令：

```bash
go build -gcflags=-m src/main.go
```

来查看是否有内存逃逸

我们调整一下代码

```go
func test26() []int {
	a := []int{1, 2, 3}
	a[1] = 4
	return a
}

func main() {
	test26()
}
```

```bash
➜ go build -gcflags=-m src/main.go
# command-line-arguments
src/main.go:490:6: can inline test26
src/main.go:496:6: can inline main
src/main.go:497:8: inlining call to test26
src/main.go:491:12: []int{...} escapes to heap
src/main.go:497:8: []int{...} does not escape

```

**src/main.go:491:12: []int{...} escapes to heap**这里发生了内存逃逸

我们在函数里定义了`a`并且返回出去，外部就会继续使用或者引用它，就会把它分配到堆上，这部分就发生了逃逸。

:::tip 注意

局部变量原本应该在栈中分配，在栈中回收，由于返回时被外部引用，所以发生逃逸，分配到了堆上。

:::

:::danger

参数为`interface`类型，比如`fmt.Println(a ...interface{})`，编译期间很难确定其参数的具体类型，也能产生逃逸。

所以在开发过程中，能确认具体的类型，就具体的写对应的类型；而且在生产环境中我们最好不要加上那些打印信息。

:::

---

```go
type User struct {
	id int
}

func NewUser() *User {
	return &User{101}
}

func main() {
	u := NewUser()
	fmt.Println(u)
}
```

```bash
➜ go build -gcflags=-m src/main.go
# command-line-arguments
src/main.go:502:6: can inline NewUser
src/main.go:507:14: inlining call to NewUser
src/main.go:508:13: inlining call to fmt.Println
src/main.go:503:9: &User{...} escapes to heap
src/main.go:507:14: &User{...} escapes to heap
src/main.go:508:13: []interface {}{...} does not escape
<autogenerated>:1: .this does not escape

```

上述代码发生了 2 次逃逸。

:::tip

如果你的`u`变量就在`main`函数里就直接就结束了，这种是没有必要使用`NewUser`这种方式，也没必要加上指针。当你把指针去掉之后，就会产生一次逃逸。

:::
