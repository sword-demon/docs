# 简述 Raft 协议

## 场景

### 单机模式

> 一焚俱焚，如果这个节点发生宕机，那么它的数据就会丢失，而且无法对外提供服务，并且数据无法恢复。

### 分布式

分布式集群：

> 一旦单节点宕机，其他节点依然能提供服务

关键的是：数据并不会丢失，其中一个重要过程就是**数据一致性**

要实现一致性：一般来讲节点中需要有个主节点来对数据日志进行统一管理【复制】

## 选举机制

### 案例

比如部署 3 个 etcd

假设有如下角色：

-   领导者：leader 主节点
-   跟随者：follower
-   候选者：candidate

> 三个节点，初始状态都是`follower`，都有个`term`值都是 0，`term`代表了任期
>
> 并且随机分配一个随机时间给 3 个节点。

---

:::tip 正常情况下

假设现在有 A B C 三个节点，随机分配给这三个节点一个随机时间，哪一个最短，哪一个先发起“选举投票”；

假设“A”先苏醒，它要干 3 件事：

1.  A 设置`term = 1`，并把自己角色改为`candidate`
2.  给自己投一票
3.  给其他 2 个节点发生`Msg(带term值)`，等待回复【就是等待 B 和 C 是否对自己投票】

---

B 节点收到 A 发送来的投票`Msg`，并获取`term`值，发现自己的比 A 小，则

1.  继续保持`follower`角色
2.  把自己的`term`也改成 1
3.  向 A 节点回执`Msg`

---

依次类推，C 也会干上面的事情，最终 A 会赢得选举【大多数选票】

于是，它会立刻给所有节点发生心跳消息，避免其余节点触发新的选举。

:::

:::warning 不正常的情况

由于网络等原因，A 和 B 也许会同时发起选举

**注意：在同一任期内，C 只能给 A 或者 B 投一票，先来先得**

> 假设 A 先得到，此时还是 A 胜出

还是那样，A 胜出之后会发出心跳消息。B 发现 A 的`term`比他大，则会自觉的改成`follower`，并更新`term`，反之亦然。

:::

## 为什么要设置奇数节点数

上面的案例说的是 3 个节点，也就是奇数节点，那么我们换成偶数节点，就会发现会出现，**A 和 B 出现平票的状态，将不会产生`leader`**，这样集群就是废的，不可以提供服务。

:::danger 注意

如果是偶数节点，这样容易发生平票

就得等待超时后继续发起投票

从而延长了系统选举的时间

:::

## 数据复制过程(初级)

> 根据上面的案例，A,B,C 三个节点一般如果想要实现数据复制，使用日志的方式，比如 MySQL 就有一个`bin-log`日志，存储使用过程中的命令到本地日志，如果机器宕机重启后可以根据这些存储命令的日志恢复数据。

### 基本过程

所有日志都必须首先提交至`leader`节点

1.  `leader`加入本地日志
2.  `leader`要求`followers`同步日志
3.  `leader`等待多数节点的反馈【不是全部】
4.  第三点成功后`leader`确认操作 OK,并修改本地状态和存储
5.  发出心跳要求`folower`也提交并存储
